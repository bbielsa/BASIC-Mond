/*
    BASIC LEXER

    THIS DOCUMENT IS CLOSED SOURCE
    IF YOU ARE READING THIS: STOP!
*/

var position = 0;
var input = "";
var tokens = [];

var LETTERS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
var SYMBOLS = ";:=+-*/()";
var TOKENS = {
    NUMBER: 0,
    LETTER: 1,
    QUOTE: 2,
    WHITESPACE: 3,
    SYMBOL: 4,
    EOF: -1
};


fun type(token) {
    var code = token.charCodeAt(0);

    if(token == "\"" || token == "'")
        return TOKENS.QUOTE;
    else if(code >= 48 && code <= 57)
        return TOKENS.NUMBER;
    else if(LETTERS.indexOf(token) > -1)
        return TOKENS.LETTER;
    else if(token.trim() == "")
        return TOKENS.WHITESPACE;
    else if(SYMBOLS.indexOf(token) > -1)
        return TOKENS.SYMBOL;
}

fun next() {
    return input.charAt(++position);
}

fun hasmore() {
    return position + 1 < input.length();
}

fun current() {
    return input.charAt(position);
}

fun take(expected) {
    if(type(expected) == type(next()))
        return true;

    return false;
}


fun peek(forward) {
    forward = forward || 1;
    if(forward + position < input.length())
        return input.charAt(forward + position);
}


fun parseString() {
    var str = "";
    var n = next(); //skip the first '

    while(type(n) != TOKENS.QUOTE) {
        str += n;

        if(!hasmore())
            break;

        n = next();
    }

    return str;
}

fun parseNumber() {
    var num = "";
    var n = current();

    while(type(n) == TOKENS.NUMBER)
    {
        num += n;

        if(!hasmore())
            break;

        if(type(peek(1)) == TOKENS.NUMBER)
            n = next();
        else
            break;
    }
    return Json.deserialize(num);
}

fun parseName() {
    var name = "";
    var n = current();

    while(type(n) == TOKENS.LETTER)
    {
        name += n;

        if(!hasmore())
            break;


        if(type(peek(1)) == TOKENS.LETTER)
            n = next();
        else
            break;

    }
    return name;
}

fun scan() {
    var n = current();

    while(position < input.length())
    {
        if(type(n) == TOKENS.QUOTE)
            tokens.add({type: "string", lexeme: parseString()});
        else if(type(n) == TOKENS.NUMBER)
            tokens.add({type: "number", lexeme: parseNumber()});
        else if(type(n) == TOKENS.LETTER)
            tokens.add({type: "name", lexeme: parseName()});
        else if(type(n) == TOKENS.SYMBOL)
            tokens.add({type: "symbol", lexeme: current()});

        if(hasmore())
            n = next();
        else
            break;
    }

    return tokens;
}

fun lexer(str) {
    position = 0;
    input = str;
    tokens = [];
    return {
        scan: fun() -> scan()
    };
}

fun new(str) {
    var _position = 0;
    var _input = str;
    var _tokens = [];
    var lex = {};
    lex.setPrototype(lexer(str));
    lex.this = lex;
    return lex;
}

return {lexer, new};
